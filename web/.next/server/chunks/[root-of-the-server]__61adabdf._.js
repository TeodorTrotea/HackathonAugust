module.exports = [
"[project]/web/.next-internal/server/app/api/chat/route/actions.js [app-rsc] (server actions loader, ecmascript)", ((__turbopack_context__, module, exports) => {

}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/action-async-storage.external.js", () => require("next/dist/server/app-render/action-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/punycode [external] (punycode, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/string_decoder [external] (string_decoder, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/node:fs [external] (node:fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:fs", () => require("node:fs"));

module.exports = mod;
}),
"[externals]/node:stream [external] (node:stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}),
"[externals]/node:stream/web [external] (node:stream/web, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream/web", () => require("node:stream/web"));

module.exports = mod;
}),
"[externals]/node:crypto [external] (node:crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[project]/web/lib/langchain-agent.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f40$langchain$2f$openai$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/web/node_modules/@langchain/openai/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$chat_models$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/web/node_modules/@langchain/openai/dist/chat_models.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$embeddings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/web/node_modules/@langchain/openai/dist/embeddings.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$langchain$2f$vectorstores$2f$memory$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/web/node_modules/langchain/vectorstores/memory.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$langchain$2f$dist$2f$vectorstores$2f$memory$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/web/node_modules/langchain/dist/vectorstores/memory.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$langchain$2f$document$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/web/node_modules/langchain/document.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$langchain$2f$dist$2f$document$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/web/node_modules/langchain/dist/document.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f40$langchain$2f$core$2f$prompts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/web/node_modules/@langchain/core/prompts.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$prompts$2f$prompt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/web/node_modules/@langchain/core/dist/prompts/prompt.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f40$langchain$2f$core$2f$tools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/web/node_modules/@langchain/core/tools.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$tools$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/web/node_modules/@langchain/core/dist/tools/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$langchain$2f$agents$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/web/node_modules/langchain/agents.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$langchain$2f$dist$2f$agents$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/web/node_modules/langchain/dist/agents/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
;
;
;
;
;
;
;
;
;
class LangChainEventAgent {
    llm;
    embeddings;
    vectorStore = null;
    events = [];
    agent = null;
    isInitialized = false;
    constructor(){
        this.llm = new __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$chat_models$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ChatOpenAI"]({
            modelName: process.env.OPENAI_MODEL || 'gpt-4o-mini',
            temperature: 0.3,
            openAIApiKey: process.env.OPENAI_API_KEY
        });
        this.embeddings = new __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f40$langchain$2f$openai$2f$dist$2f$embeddings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["OpenAIEmbeddings"]({
            openAIApiKey: process.env.OPENAI_API_KEY,
            modelName: 'text-embedding-3-small'
        });
        this.initialize();
    }
    async initialize() {
        if (this.isInitialized) return;
        console.log('🚀 Initializing LangChain Event Agent...');
        // Load events from CSV
        await this.loadEvents();
        // Create vector store with embeddings
        await this.createVectorStore();
        // Set up agent with tools
        await this.setupAgent();
        this.isInitialized = true;
        console.log('✅ LangChain Agent initialized successfully');
    }
    async loadEvents() {
        try {
            const csvPath = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(process.cwd(), '../data/events_export.csv');
            const csvContent = __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(csvPath, 'utf-8');
            const lines = csvContent.trim().split('\n');
            const headers = lines[0].split(',');
            // More robust CSV parsing
            this.events = [];
            for(let lineIndex = 1; lineIndex < lines.length; lineIndex++){
                try {
                    const line = lines[lineIndex];
                    if (!line || line.trim() === '') continue;
                    const values = [];
                    let current = '';
                    let inQuotes = false;
                    for(let i = 0; i < line.length; i++){
                        const char = line[i];
                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            values.push(current.trim().replace(/^"|"$/g, ''));
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    values.push(current.trim().replace(/^"|"$/g, ''));
                    // Map values to headers
                    const event = {};
                    headers.forEach((header, index)=>{
                        const value = values[index] || '';
                        // Clean header names
                        const cleanHeader = header.trim().toLowerCase().replace(/\s+/g, '_');
                        event[cleanHeader] = value;
                    });
                    // Normalize the event structure
                    const normalizedEvent = {
                        id: event.id || `generated-${lineIndex}`,
                        title: event.title || 'Untitled Event',
                        description: event.description || '',
                        date: event.date || '',
                        time: event.time || null,
                        location: event.location || '',
                        type: event.type || 'Event',
                        image_url: event.image_url || '',
                        registration_url: event.registration_url || '',
                        tags: event.tags || '',
                        status: event.status || 'published'
                    };
                    // Validate the event has minimum required fields
                    if (normalizedEvent.title && normalizedEvent.title !== 'Untitled Event') {
                        // Additional validation - skip if title looks like raw data
                        if (!normalizedEvent.title.includes(',') || normalizedEvent.title.length < 100) {
                            this.events.push(normalizedEvent);
                        } else {
                            console.warn(`Skipping event with malformed title at line ${lineIndex + 1}`);
                        }
                    }
                } catch (error) {
                    console.warn(`Error parsing CSV line ${lineIndex + 1}:`, error);
                }
            }
            console.log(`📚 Loaded ${this.events.length} events for LangChain processing`);
        } catch (error) {
            console.error('Error loading events:', error);
            this.events = [];
        }
    }
    async createVectorStore() {
        if (this.events.length === 0) return;
        console.log('🔗 Creating vector embeddings for events...');
        // Create documents for vector store, filtering out malformed events
        const documents = this.events.filter((event)=>{
            // Additional validation before creating embeddings
            if (!event.title || event.title.length > 200) return false;
            if (!event.id) return false;
            // Check if description looks like raw CSV data
            if (event.description && event.description.includes(',2025-') && event.description.includes('+00')) {
                console.warn(`Skipping malformed event in vector store: ${event.title}`);
                return false;
            }
            return true;
        }).map((event)=>{
            // Clean up the content for better embeddings
            const cleanDescription = event.description && event.description.length < 1000 ? event.description : event.description?.substring(0, 500) + '...';
            const content = `
Title: ${event.title}
Description: ${cleanDescription || 'No description available'}
Type: ${event.type || 'Event'}
Location: ${event.location || 'TBD'}
Date: ${event.date || 'TBD'}
Tags: ${event.tags || ''}
        `.trim();
            return new __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$langchain$2f$dist$2f$document$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Document"]({
                pageContent: content,
                metadata: {
                    eventId: event.id,
                    title: event.title.substring(0, 100),
                    type: event.type || 'Event',
                    location: event.location || 'TBD',
                    date: event.date || '',
                    tags: event.tags || ''
                }
            });
        });
        // Create vector store from documents
        this.vectorStore = await __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$langchain$2f$dist$2f$vectorstores$2f$memory$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MemoryVectorStore"].fromDocuments(documents, this.embeddings);
        console.log(`🎯 Vector store created with ${documents.length} event embeddings`);
    }
    async setupAgent() {
        if (!this.vectorStore) return;
        // Create semantic search tool
        const semanticSearchTool = new __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$tools$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Tool"]({
            name: 'semantic_event_search',
            description: `
        Performs semantic search through tech events database using vector similarity.
        Input should be a natural language description of what the user is looking for.
        Returns the most relevant events with similarity scores.
        Use this tool when the user wants to find events related to specific topics, technologies, or interests.
      `,
            func: async (query)=>{
                if (!this.vectorStore) return 'Vector store not initialized';
                try {
                    // Perform similarity search
                    const results = await this.vectorStore.similaritySearchWithScore(query, 15);
                    const searchResults = results.map(([doc, score], index)=>({
                            rank: index + 1,
                            eventId: doc.metadata.eventId,
                            title: doc.metadata.title,
                            type: doc.metadata.type,
                            location: doc.metadata.location,
                            date: doc.metadata.date,
                            similarity: Math.round(score * 100) / 100,
                            preview: doc.pageContent.substring(0, 200) + '...'
                        }));
                    return JSON.stringify({
                        query,
                        resultsFound: results.length,
                        topResults: searchResults
                    });
                } catch (error) {
                    return `Search error: ${error}`;
                }
            }
        });
        // Create event details tool
        const getEventDetailsTool = new __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$tools$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Tool"]({
            name: 'get_event_details',
            description: `
        Gets full details for specific events by their IDs.
        Input should be a comma-separated list of event IDs.
        Use this after semantic search to get complete information about selected events.
      `,
            func: async (eventIds)=>{
                const ids = eventIds.split(',').map((id)=>id.trim());
                const matchedEvents = this.events.filter((event)=>ids.includes(event.id));
                return JSON.stringify({
                    requestedIds: ids,
                    foundEvents: matchedEvents.map((event)=>({
                            id: event.id,
                            title: event.title,
                            description: event.description,
                            date: event.date,
                            time: event.time,
                            location: event.location,
                            type: event.type,
                            tags: event.tags,
                            registrationUrl: event.registration_url
                        }))
                });
            }
        });
        // Create agent prompt
        const prompt = __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f40$langchain$2f$core$2f$dist$2f$prompts$2f$prompt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PromptTemplate"].fromTemplate(`
You are an expert tech events assistant powered by LangChain with semantic search capabilities. 
Your job is to help users find the most relevant tech events in Belgium and Netherlands.

AVAILABLE TOOLS:
- semantic_event_search: Find events using semantic similarity search
- get_event_details: Get complete details for specific events

WORKFLOW:
1. Understand what the user is really looking for (be generous in interpretation)
2. Use semantic_event_search with a well-crafted query that captures their intent
3. Analyze the search results and select the most relevant events
4. Use get_event_details to get full information for the selected events
5. Present the results with clear explanations of why each event is relevant

GUIDELINES:
- Be generous with search terms - cast a wide net
- Look for semantic connections, not just keyword matches
- Consider related technologies, concepts, and interests
- Explain why each event is relevant to the user's query
- Provide actionable recommendations
- If few results found, try broader search terms

Current conversation:
Human: {input}

{agent_scratchpad}
    `);
        // Create agent
        const agent = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$langchain$2f$dist$2f$agents$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createOpenAIToolsAgent"])({
            llm: this.llm,
            tools: [
                semanticSearchTool,
                getEventDetailsTool
            ],
            prompt
        });
        this.agent = new __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$langchain$2f$dist$2f$agents$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AgentExecutor"]({
            agent,
            tools: [
                semanticSearchTool,
                getEventDetailsTool
            ],
            verbose: true,
            maxIterations: 5
        });
        console.log('🤖 LangChain agent with semantic search tools ready');
    }
    async processQuery(userMessage) {
        await this.initialize();
        if (!this.agent) {
            throw new Error('Agent not initialized');
        }
        console.log(`🔍 LangChain agent processing: "${userMessage}"`);
        const processingSteps = [];
        const vectorSimilarityScores = {};
        try {
            // Execute the agent
            processingSteps.push('Agent execution started');
            const result = await this.agent.invoke({
                input: userMessage
            });
            processingSteps.push('Agent execution completed');
            // Parse the agent's response to extract event IDs and search terms
            const output = result.output;
            let events = [];
            let relevanceScores = [];
            // Try to extract event IDs from the agent's intermediate steps
            if (result.intermediateSteps) {
                for (const step of result.intermediateSteps){
                    if (step.action?.tool === 'get_event_details' && step.observation) {
                        try {
                            const parsedObservation = JSON.parse(step.observation);
                            if (parsedObservation.foundEvents) {
                                // Use a Map to deduplicate events
                                const uniqueEventsMap = new Map();
                                parsedObservation.foundEvents.forEach((eventData)=>{
                                    try {
                                        // Find the original event for complete data
                                        const originalEvent = this.events.find((e)=>e.id === eventData.id);
                                        if (!originalEvent) {
                                            console.warn(`Original event not found for ID: ${eventData.id}`);
                                            return;
                                        }
                                        const processedEvent = {
                                            id: originalEvent.id || `generated-${Date.now()}-${Math.random()}`,
                                            title: String(originalEvent.title || '').trim(),
                                            description: String(originalEvent.description || '').trim(),
                                            date: String(originalEvent.date || ''),
                                            time: originalEvent.time || null,
                                            location: String(originalEvent.location || '').trim(),
                                            type: String(originalEvent.type || '').trim(),
                                            image_url: String(originalEvent.image_url || '').trim(),
                                            registration_url: String(originalEvent.registration_url || '').trim(),
                                            tags: String(originalEvent.tags || '').trim(),
                                            status: 'published'
                                        };
                                        // Only add if we have a valid title and it's not a duplicate
                                        if (processedEvent.title) {
                                            const uniqueKey = `${processedEvent.id}-${processedEvent.title.substring(0, 50)}`;
                                            if (!uniqueEventsMap.has(uniqueKey)) {
                                                uniqueEventsMap.set(uniqueKey, processedEvent);
                                            }
                                        }
                                    } catch (error) {
                                        console.error(`Error processing event data:`, error);
                                    }
                                });
                                events = Array.from(uniqueEventsMap.values());
                                processingSteps.push(`Retrieved details for ${events.length} events`);
                            }
                        } catch (e) {
                            console.error('Error parsing event details:', e);
                        }
                    }
                    if (step.action?.tool === 'semantic_event_search' && step.observation) {
                        try {
                            const searchResult = JSON.parse(step.observation);
                            if (searchResult.topResults) {
                                searchResult.topResults.forEach((result)=>{
                                    vectorSimilarityScores[result.eventId] = result.similarity;
                                });
                                relevanceScores = searchResult.topResults.map((r)=>r.similarity);
                                processingSteps.push(`Semantic search found ${searchResult.resultsFound} results`);
                            }
                        } catch (e) {
                            console.error('Error parsing search results:', e);
                        }
                    }
                }
            }
            // If we didn't get events from the agent steps, try a fallback search
            if (events.length === 0 && this.vectorStore) {
                processingSteps.push('Performing fallback semantic search');
                const fallbackResults = await this.vectorStore.similaritySearchWithScore(userMessage, 20);
                // Use a Map to prevent duplicates based on event ID
                const uniqueEventsMap = new Map();
                fallbackResults.forEach(([doc])=>{
                    const eventId = doc.metadata.eventId;
                    const event = this.events.find((e)=>e.id === eventId);
                    if (event && event.title && typeof event.title === 'string' && event.title.trim()) {
                        // Use a composite key to prevent duplicates
                        const uniqueKey = `${event.id || 'no-id'}-${event.title.substring(0, 50)}`;
                        if (!uniqueEventsMap.has(uniqueKey)) {
                            uniqueEventsMap.set(uniqueKey, {
                                ...event,
                                id: event.id || `generated-${Date.now()}-${Math.random()}`
                            });
                        }
                    }
                });
                events = Array.from(uniqueEventsMap.values()).slice(0, 12);
                relevanceScores = fallbackResults.slice(0, events.length).map(([, score])=>score);
                events.forEach((event, idx)=>{
                    if (fallbackResults[idx]) {
                        vectorSimilarityScores[event.id] = fallbackResults[idx][1];
                    }
                });
            }
            return {
                message: output,
                events,
                relevanceScores,
                searchQuery: userMessage,
                processingSteps,
                vectorSimilarityScores
            };
        } catch (error) {
            console.error('LangChain agent error:', error);
            processingSteps.push(`Error: ${error}`);
            // Fallback to direct semantic search
            if (this.vectorStore) {
                processingSteps.push('Using direct semantic search fallback');
                const fallbackResults = await this.vectorStore.similaritySearchWithScore(userMessage, 8);
                const events = fallbackResults.map(([doc])=>{
                    const eventId = doc.metadata.eventId;
                    return this.events.find((e)=>e.id === eventId);
                }).filter(Boolean);
                return {
                    message: `I found ${events.length} relevant events using semantic search, though I encountered an issue with the full analysis.`,
                    events,
                    relevanceScores: fallbackResults.map(([, score])=>score),
                    searchQuery: userMessage,
                    processingSteps,
                    vectorSimilarityScores: {}
                };
            }
            throw error;
        }
    }
}
const __TURBOPACK__default__export__ = LangChainEventAgent;
}),
"[project]/web/app/api/chat/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/web/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$lib$2f$langchain$2d$agent$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/web/lib/langchain-agent.ts [app-route] (ecmascript)");
;
;
async function POST(request) {
    try {
        const { message, conversationHistory } = await request.json();
        if (!message || typeof message !== 'string') {
            return __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                response: "Please provide a valid message.",
                events: [],
                processingSteps: [],
                vectorSimilarityScores: {},
                error: "Invalid input"
            }, {
                status: 400
            });
        }
        // Check if OpenAI API key is configured
        if (!process.env.OPENAI_API_KEY) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                response: "OpenAI API key is not configured. Please add OPENAI_API_KEY to your .env file.",
                events: [],
                processingSteps: [],
                vectorSimilarityScores: {},
                error: "Missing API key"
            }, {
                status: 500
            });
        }
        console.log(`🔗 LangChain chat processing: "${message}"`);
        const startTime = Date.now();
        // Use LangChain agent exclusively
        const agent = new __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$lib$2f$langchain$2d$agent$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]();
        const result = await agent.processQuery(message);
        const processingTime = Date.now() - startTime;
        console.log(`🎯 LangChain processing complete:`);
        console.log(`   - Events found: ${result.events.length}`);
        console.log(`   - Processing steps: ${result.processingSteps.length}`);
        console.log(`   - Total time: ${processingTime}ms`);
        return __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            response: result.message,
            events: result.events,
            relevanceScores: result.relevanceScores,
            searchQuery: result.searchQuery,
            processingSteps: result.processingSteps,
            vectorSimilarityScores: result.vectorSimilarityScores,
            processingTime,
            agentType: 'langchain'
        });
    } catch (error) {
        console.error('LangChain chat API error:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            response: "I encountered an error while processing your request with LangChain. Please try again.",
            events: [],
            processingSteps: [
                `Error: ${error instanceof Error ? error.message : 'Unknown error'}`
            ],
            vectorSimilarityScores: {},
            error: error instanceof Error ? error.message : 'Unknown error'
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__61adabdf._.js.map