module.exports = [
"[project]/web/.next-internal/server/app/api/chat/route/actions.js [app-rsc] (server actions loader, ecmascript)", ((__turbopack_context__, module, exports) => {

}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/action-async-storage.external.js", () => require("next/dist/server/app-render/action-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/punycode [external] (punycode, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/string_decoder [external] (string_decoder, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/node:fs [external] (node:fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:fs", () => require("node:fs"));

module.exports = mod;
}),
"[externals]/node:stream [external] (node:stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}),
"[externals]/node:stream/web [external] (node:stream/web, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream/web", () => require("node:stream/web"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[project]/web/lib/smart-agent.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$openai$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/web/node_modules/openai/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
;
;
;
class SmartEventAgent {
    openai;
    events = [];
    defaultModel;
    constructor(){
        this.openai = new __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$openai$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"]({
            apiKey: process.env.OPENAI_API_KEY
        });
        this.defaultModel = process.env.OPENAI_MODEL || 'gpt-4o-mini';
        this.loadEvents();
    }
    getModel(task) {
        // Allow different models for different tasks
        if (task === 'intent' && process.env.OPENAI_MODEL_INTENT) {
            return process.env.OPENAI_MODEL_INTENT;
        }
        if (task === 'evaluation' && process.env.OPENAI_MODEL_EVALUATION) {
            return process.env.OPENAI_MODEL_EVALUATION;
        }
        if (task === 'response' && process.env.OPENAI_MODEL_RESPONSE) {
            return process.env.OPENAI_MODEL_RESPONSE;
        }
        // Fall back to default model
        return this.defaultModel;
    }
    loadEvents() {
        try {
            const csvPath = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(process.cwd(), '../data/events_export.csv');
            const csvContent = __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(csvPath, 'utf-8');
            const lines = csvContent.trim().split('\n');
            const headers = lines[0].split(',');
            this.events = lines.slice(1).map((line)=>{
                const values = [];
                let current = '';
                let inQuotes = false;
                for(let i = 0; i < line.length; i++){
                    const char = line[i];
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        values.push(current.trim().replace(/^"|"$/g, ''));
                        current = '';
                    } else {
                        current += char;
                    }
                }
                values.push(current.trim().replace(/^"|"$/g, ''));
                const event = {};
                headers.forEach((header, index)=>{
                    event[header] = values[index] || '';
                });
                return event;
            });
        } catch (error) {
            console.error('Failed to load events:', error);
        }
    }
    async interpretUserIntent(userMessage, conversationHistory = []) {
        const conversationContext = conversationHistory.length > 0 ? `Previous conversation:\n${conversationHistory.slice(-6).map((msg)=>`${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}`).join('\n')}\n\n` : '';
        const systemPrompt = `You are an expert at understanding user intent for tech event searches. Analyze the user's request deeply and extract their true intent, preferences, and constraints.

${conversationContext}Current user message: "${userMessage}"

Extract and infer:
1. PRIMARY REQUEST: What they really want (not just keywords)
2. PREFERENCES: What they'd prefer but isn't mandatory
3. CONSTRAINTS: Hard requirements that must be met
4. SENTIMENT: How they're approaching the search

Examples of deep interpretation:
- "I'm new to machine learning" â†’ skillLevel: beginner, interests: [learning, fundamentals]
- "Something this weekend" â†’ timeframe: this_weekend, dateRange
- "Not too corporate" â†’ mustNotHave: [corporate], format: informal
- "I work with Python" â†’ technology: [python], interests: [python-related]
- "Free events only" â†’ cost: free
- "Something hands-on" â†’ format: workshop, preferences: [practical, interactive]
- "I'm between jobs" â†’ cost: free, interests: [networking, career]
- "Quick overview" â†’ format: short, timeframe: brief
- "Deep dive" â†’ format: detailed, skillLevel: advanced`;
        try {
            const response = await this.openai.chat.completions.create({
                model: this.getModel('intent'),
                messages: [
                    {
                        role: 'system',
                        content: systemPrompt
                    },
                    {
                        role: 'user',
                        content: `Analyze this request: "${userMessage}"`
                    }
                ],
                tools: [
                    {
                        type: 'function',
                        function: {
                            name: 'extract_user_intent',
                            description: 'Extract detailed user intent from natural language',
                            parameters: {
                                type: 'object',
                                properties: {
                                    primaryRequest: {
                                        type: 'string'
                                    },
                                    preferences: {
                                        type: 'object',
                                        properties: {
                                            timeframe: {
                                                type: 'string'
                                            },
                                            location: {
                                                type: 'string'
                                            },
                                            eventTypes: {
                                                type: 'array',
                                                items: {
                                                    type: 'string'
                                                }
                                            },
                                            skillLevel: {
                                                type: 'string'
                                            },
                                            format: {
                                                type: 'string'
                                            },
                                            cost: {
                                                type: 'string'
                                            },
                                            company: {
                                                type: 'string'
                                            },
                                            technology: {
                                                type: 'array',
                                                items: {
                                                    type: 'string'
                                                }
                                            },
                                            interests: {
                                                type: 'array',
                                                items: {
                                                    type: 'string'
                                                }
                                            }
                                        }
                                    },
                                    constraints: {
                                        type: 'object',
                                        properties: {
                                            mustHave: {
                                                type: 'array',
                                                items: {
                                                    type: 'string'
                                                }
                                            },
                                            mustNotHave: {
                                                type: 'array',
                                                items: {
                                                    type: 'string'
                                                }
                                            },
                                            dateRange: {
                                                type: 'object',
                                                properties: {
                                                    start: {
                                                        type: 'string'
                                                    },
                                                    end: {
                                                        type: 'string'
                                                    }
                                                }
                                            },
                                            maxResults: {
                                                type: 'number'
                                            }
                                        }
                                    },
                                    sentiment: {
                                        type: 'string',
                                        enum: [
                                            'enthusiastic',
                                            'specific',
                                            'exploring',
                                            'urgent'
                                        ]
                                    }
                                },
                                required: [
                                    'primaryRequest',
                                    'preferences',
                                    'constraints',
                                    'sentiment'
                                ]
                            }
                        }
                    }
                ],
                tool_choice: {
                    type: 'function',
                    function: {
                        name: 'extract_user_intent'
                    }
                }
            });
            const toolCall = response.choices[0].message.tool_calls?.[0];
            if (toolCall && toolCall.function.arguments) {
                return JSON.parse(toolCall.function.arguments);
            }
        } catch (error) {
            console.error('Error interpreting user intent:', error);
        }
        // Fallback intent
        return {
            primaryRequest: userMessage,
            preferences: {},
            constraints: {},
            sentiment: 'exploring'
        };
    }
    basicFilter(intent) {
        let filteredEvents = this.events;
        // Apply hard constraints first
        if (intent.preferences.location) {
            filteredEvents = filteredEvents.filter((event)=>event.location.toLowerCase().includes(intent.preferences.location.toLowerCase()));
        }
        // Date filtering with intelligent interpretation
        if (intent.preferences.timeframe || intent.constraints.dateRange?.start || intent.constraints.dateRange?.end) {
            filteredEvents = filteredEvents.filter((event)=>{
                const eventDate = new Date(event.date);
                const now = new Date();
                // Handle relative timeframes
                if (intent.preferences.timeframe) {
                    const timeframe = intent.preferences.timeframe.toLowerCase();
                    if (timeframe.includes('weekend') || timeframe.includes('this weekend')) {
                        const nextSaturday = new Date(now);
                        nextSaturday.setDate(now.getDate() + (6 - now.getDay()));
                        const nextSunday = new Date(nextSaturday);
                        nextSunday.setDate(nextSaturday.getDate() + 1);
                        return eventDate >= nextSaturday && eventDate <= nextSunday;
                    } else if (timeframe.includes('week') || timeframe.includes('this week')) {
                        const weekEnd = new Date(now);
                        weekEnd.setDate(now.getDate() + 7);
                        return eventDate >= now && eventDate <= weekEnd;
                    } else if (timeframe.includes('month') || timeframe.includes('this month')) {
                        const monthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                        return eventDate >= now && eventDate <= monthEnd;
                    } else if (timeframe.includes('soon') || timeframe.includes('upcoming')) {
                        const twoWeeks = new Date(now);
                        twoWeeks.setDate(now.getDate() + 14);
                        return eventDate >= now && eventDate <= twoWeeks;
                    }
                }
                // Handle explicit date ranges
                const start = intent.constraints.dateRange?.start ? new Date(intent.constraints.dateRange.start) : new Date('2000-01-01');
                const end = intent.constraints.dateRange?.end ? new Date(intent.constraints.dateRange.end) : new Date('2030-12-31');
                return eventDate >= start && eventDate <= end;
            });
        }
        // Cost filtering (if we can infer from description)
        if (intent.preferences.cost === 'free') {
            filteredEvents = filteredEvents.filter((event)=>event.description.toLowerCase().includes('free') || event.tags.toLowerCase().includes('free') || event.registration_url.includes('free'));
        }
        // Basic keyword filtering for must-haves
        if (intent.constraints.mustHave && intent.constraints.mustHave.length > 0) {
            filteredEvents = filteredEvents.filter((event)=>{
                const searchableText = `${event.title} ${event.description} ${event.tags} ${event.type}`.toLowerCase();
                return intent.constraints.mustHave.some((mustHave)=>searchableText.includes(mustHave.toLowerCase()));
            });
        }
        // Filter out must-not-haves
        if (intent.constraints.mustNotHave && intent.constraints.mustNotHave.length > 0) {
            filteredEvents = filteredEvents.filter((event)=>{
                const searchableText = `${event.title} ${event.description} ${event.tags} ${event.type}`.toLowerCase();
                return !intent.constraints.mustNotHave.some((mustNotHave)=>searchableText.includes(mustNotHave.toLowerCase()));
            });
        }
        return filteredEvents;
    }
    async evaluateEventsBatch(events, intent, batchSize = 10) {
        const evaluatedEvents = [];
        for(let i = 0; i < events.length; i += batchSize){
            const batch = events.slice(i, i + batchSize);
            console.log(`ðŸ” Evaluating batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(events.length / batchSize)} (${batch.length} events)`);
            try {
                const batchEvaluation = await this.evaluateSingleBatch(batch, intent);
                evaluatedEvents.push(...batchEvaluation);
                // Small delay to avoid rate limits
                if (i + batchSize < events.length) {
                    await new Promise((resolve)=>setTimeout(resolve, 500));
                }
            } catch (error) {
                console.error(`Error evaluating batch ${i}-${i + batchSize}:`, error);
            // Continue with next batch
            }
        }
        return evaluatedEvents;
    }
    async evaluateSingleBatch(events, intent) {
        const eventsText = events.map((event, idx)=>`Event ${idx + 1}:
Title: ${event.title}
Description: ${event.description.substring(0, 300)}${event.description.length > 300 ? '...' : ''}
Date: ${event.date} ${event.time || ''}
Location: ${event.location}
Type: ${event.type}
Tags: ${event.tags}`).join('\n\n');
        const systemPrompt = `You are an expert event curator. Evaluate these events against the user's specific intent and preferences.

User Intent Analysis:
- Primary Request: ${intent.primaryRequest}
- Preferences: ${JSON.stringify(intent.preferences, null, 2)}
- Constraints: ${JSON.stringify(intent.constraints, null, 2)}
- Sentiment: ${intent.sentiment}

For each event, provide:
1. Relevance score (0-100): How well it matches the user's intent
2. Reasons: Why this event is relevant (be specific)
3. Concerns: Any potential issues or mismatches

Focus on deeper meaning, not just keyword matching. Consider:
- User's skill level and learning goals
- Practical vs theoretical preferences
- Networking vs learning focus
- Time constraints and availability
- Career stage and objectives
- Technical depth desired`;
        try {
            const response = await this.openai.chat.completions.create({
                model: this.getModel('evaluation'),
                messages: [
                    {
                        role: 'system',
                        content: systemPrompt
                    },
                    {
                        role: 'user',
                        content: `Evaluate these events:\n\n${eventsText}`
                    }
                ],
                tools: [
                    {
                        type: 'function',
                        function: {
                            name: 'evaluate_events',
                            description: 'Evaluate events against user intent',
                            parameters: {
                                type: 'object',
                                properties: {
                                    evaluations: {
                                        type: 'array',
                                        items: {
                                            type: 'object',
                                            properties: {
                                                eventIndex: {
                                                    type: 'number'
                                                },
                                                relevanceScore: {
                                                    type: 'number',
                                                    minimum: 0,
                                                    maximum: 100
                                                },
                                                reasons: {
                                                    type: 'array',
                                                    items: {
                                                        type: 'string'
                                                    }
                                                },
                                                concerns: {
                                                    type: 'array',
                                                    items: {
                                                        type: 'string'
                                                    }
                                                }
                                            },
                                            required: [
                                                'eventIndex',
                                                'relevanceScore',
                                                'reasons',
                                                'concerns'
                                            ]
                                        }
                                    }
                                },
                                required: [
                                    'evaluations'
                                ]
                            }
                        }
                    }
                ],
                tool_choice: {
                    type: 'function',
                    function: {
                        name: 'evaluate_events'
                    }
                }
            });
            const toolCall = response.choices[0].message.tool_calls?.[0];
            if (toolCall && toolCall.function.arguments) {
                const result = JSON.parse(toolCall.function.arguments);
                return result.evaluations.map((evaluation)=>({
                        event: events[evaluation.eventIndex],
                        relevanceScore: evaluation.relevanceScore,
                        reasons: evaluation.reasons,
                        concerns: evaluation.concerns
                    }));
            }
        } catch (error) {
            console.error('Error in batch evaluation:', error);
        }
        // Fallback: return all events with medium scores
        return events.map((event)=>({
                event,
                relevanceScore: 50,
                reasons: [
                    'Basic match'
                ],
                concerns: []
            }));
    }
    async processQuery(userMessage, conversationHistory = []) {
        console.log(`ðŸ§  Smart Agent analyzing: "${userMessage}"`);
        // Step 1: Deep intent interpretation
        const intent = await this.interpretUserIntent(userMessage, conversationHistory);
        console.log(`ðŸŽ¯ Interpreted intent:`, intent);
        // Step 2: Basic filtering based on hard constraints
        const basicFiltered = this.basicFilter(intent);
        console.log(`ðŸ“Š After basic filtering: ${basicFiltered.length} events`);
        // Step 3: LLM evaluation in batches
        const evaluatedEvents = await this.evaluateEventsBatch(basicFiltered, intent, 10);
        console.log(`âœ… Evaluated ${evaluatedEvents.length} events`);
        // Step 4: Sort by relevance and take top results
        const sortedEvents = evaluatedEvents.filter((e)=>e.relevanceScore >= 30) // Only keep reasonably relevant events
        .sort((a, b)=>b.relevanceScore - a.relevanceScore).slice(0, 5);
        console.log(`ðŸ† Final results: ${sortedEvents.length} events`);
        // Step 5: Generate intelligent response
        const finalResponse = await this.generateSmartResponse(userMessage, intent, sortedEvents, evaluatedEvents.length, conversationHistory);
        return {
            message: finalResponse,
            events: sortedEvents.map((e)=>e.event),
            reasoning: `Analyzed ${evaluatedEvents.length} events, found ${sortedEvents.length} highly relevant matches`,
            totalEvaluated: evaluatedEvents.length
        };
    }
    async generateSmartResponse(userMessage, intent, evaluatedEvents, totalEvaluated, conversationHistory) {
        const conversationContext = conversationHistory.length > 0 ? `Previous conversation:\n${conversationHistory.slice(-4).map((msg)=>`${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}`).join('\n')}\n\n` : '';
        const eventSummaries = evaluatedEvents.filter((e)=>e && e.event && e.event.title) // Safety check
        .map((e, i)=>`${i + 1}. ${e.event.title} (Score: ${e.relevanceScore})\n   Why: ${e.reasons.join(', ')}`).join('\n');
        const systemPrompt = `You are a knowledgeable AI assistant that deeply understands user intent and has intelligently analyzed events.

${conversationContext}User's original request: "${userMessage}"

Interpreted intent:
- Primary need: ${intent.primaryRequest}
- Key preferences: ${JSON.stringify(intent.preferences)}
- User sentiment: ${intent.sentiment}

Analysis results:
- Total events evaluated: ${totalEvaluated}
- Top matches found: ${evaluatedEvents.length}

Selected events:
${eventSummaries}

Generate a natural, conversational response that:
1. Shows you understood their deeper intent (not just keywords)
2. Explains why these specific events match what they're looking for
3. Addresses their skill level, interests, and constraints
4. Builds on the conversation context
5. Is enthusiastic but honest about the matches`;
        try {
            const response = await this.openai.chat.completions.create({
                model: this.getModel('response'),
                messages: [
                    {
                        role: 'system',
                        content: systemPrompt
                    },
                    {
                        role: 'user',
                        content: `Generate response for: "${userMessage}"`
                    }
                ]
            });
            return response.choices[0].message.content || `I analyzed ${totalEvaluated} events and found ${evaluatedEvents.length} that really match what you're looking for!`;
        } catch (error) {
            console.error('Error generating smart response:', error);
            return `I analyzed ${totalEvaluated} events and found ${evaluatedEvents.length} that match your interests!`;
        }
    }
}
const __TURBOPACK__default__export__ = SmartEventAgent;
}),
"[project]/web/app/api/chat/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/web/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$lib$2f$smart$2d$agent$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/web/lib/smart-agent.ts [app-route] (ecmascript)");
;
;
async function POST(request) {
    try {
        const { message, conversationHistory } = await request.json();
        if (!message || typeof message !== 'string') {
            return __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                response: "Please provide a valid message.",
                events: []
            }, {
                status: 400
            });
        }
        // Check if OpenAI API key is configured
        if (!process.env.OPENAI_API_KEY) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                response: "OpenAI API key is not configured. Please add OPENAI_API_KEY to your .env file.",
                events: []
            }, {
                status: 500
            });
        }
        // Validate AI model configuration
        const validModels = [
            'gpt-4o',
            'gpt-4o-mini',
            'gpt-4-turbo',
            'gpt-4',
            'gpt-3.5-turbo'
        ];
        const configuredModel = process.env.OPENAI_MODEL || 'gpt-4o-mini';
        if (!validModels.includes(configuredModel)) {
            console.warn(`Warning: Configured model '${configuredModel}' is not in the list of known valid models. Proceeding anyway.`);
        }
        // Create smart agent with deep interpretation and LLM evaluation
        const agent = new __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$lib$2f$smart$2d$agent$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]();
        const result = await agent.processQuery(message, conversationHistory || []);
        return __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            response: result.message,
            events: result.events
        });
    } catch (error) {
        console.error('Chat API error:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$web$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            response: "I'm sorry, I encountered an error while processing your request. Please try again.",
            events: []
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__28715495._.js.map